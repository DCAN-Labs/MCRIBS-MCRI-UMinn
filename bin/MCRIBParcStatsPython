#!/usr/bin/env python

import numpy
import sys
import os
import nibabel
import pandas

import freesurfer
import GraphUtils

if len(sys.argv) < 4:
	print "Incorrect number of arguments"
	print
	print "Usage: " + sys.argv[0] + " <subject id> <hemi>"
	print "Performs the parcellation stats on the white matter surface given a parcellation annot file"
	quit()

# ColHeaders  Index SegId NVoxels Volume_mm3 StructName normMean normStdDev normMin normMax normRange

try:
	SubjectsDir = os.environ['SUBJECTS_DIR']
except Exception:
	print "Could not find the SUBJECTS_DIR environment variable"
	exit()

SubjectID = sys.argv[1]
Hemis = sys.argv[2]
Atlas = sys.argv[3]

if Hemis == 'both':
	Hemis = ['lh', 'rh']
else:
	Hemis = [Hemis]

# check for all the files

def checkFilesReturnNameOnFailure(fileList):
	for curFile in fileList:
		if not os.path.isfile(curFile):
			return curFile
	return None

for Hemi in Hemis:
	LabelFileName = os.path.join(SubjectsDir, SubjectID, 'label', Hemi + '.cortex.label')
	AreaFileName = os.path.join(SubjectsDir, SubjectID, 'surf', Hemi + '.area')
	ThicknessFileName = os.path.join(SubjectsDir, SubjectID, 'surf', Hemi + '.thickness')
	AnnotFileName = os.path.join(SubjectsDir, SubjectID, 'label', Hemi + "." + Atlas + ".annot")
	WhiteSurfFileName = os.path.join(SubjectsDir, SubjectID, 'surf', Hemi + ".white")
	MeanCurvFileName = os.path.join(SubjectsDir, SubjectID, 'surf', Hemi + ".smoothwm.H.crv")
	GaussCurvFileName = os.path.join(SubjectsDir, SubjectID, 'surf', Hemi + ".smoothwm.K.crv")
	K1CurvFileName = os.path.join(SubjectsDir, SubjectID, 'surf', Hemi + ".smoothwm.K1.crv")
	K2CurvFileName = os.path.join(SubjectsDir, SubjectID, 'surf', Hemi + ".smoothwm.K2.crv")

	R = checkFilesReturnNameOnFailure([LabelFileName, AreaFileName, ThicknessFileName, AnnotFileName, MeanCurvFileName, GaussCurvFileName])

	if not R is None:
		print "Could not find: " + R
		quit()

	CortexLabel = freesurfer.readLabel(LabelFileName)
	AreaData = freesurfer.readCurv(AreaFileName)
	ThicknessData = freesurfer.readCurv(ThicknessFileName)
	MeanCurvData = freesurfer.readCurv(MeanCurvFileName)
	GaussCurvData = freesurfer.readCurv(GaussCurvFileName)
	K1CurvData = freesurfer.readCurv(K1CurvFileName)
	K2CurvData = freesurfer.readCurv(K2CurvFileName)
	WhiteSurf = freesurfer.readSurf(WhiteSurfFileName)

	vertexNeighbours = GraphUtils.getVertexNeighbours(WhiteSurf)

	Annot = freesurfer.readAnnot(AnnotFileName)
	CortexLabelIDX = CortexLabel['index']
	CortexLabelMask = numpy.zeros(Annot['seg'].size, dtype = numpy.bool)
	CortexLabelMask[CortexLabelIDX] = True

	AreaValues = AreaData['values']
	ThicknessValues = ThicknessData['values']
	MeanCurvValues = MeanCurvData['values']
	GaussCurvValues = GaussCurvData['values']
	K1CurvValues = K1CurvData['values']
	K2CurvValues = K2CurvData['values']
	
	outDF = pandas.DataFrame(columns = ['StructName', 'NumVert', 'SurfArea', 'GrayVol', 'ThickAvg', 'ThickStd', 'MeanCurv', 'GausCurv', 'FoldInd', 'CurvInd'])
	outDF.StructName = Annot['colortable']['struct_names']

	outDF = outDF[outDF.StructName != 'ctx-' + Hemi + '-unknown']

	for curStructIDX in outDF.index:
		I = numpy.where(numpy.logical_and(Annot['seg'] == curStructIDX, CortexLabelMask))[0]
		if I.size > 0:
			outDF.loc[curStructIDX, 'NumVert'] = I.size
			outDF.loc[curStructIDX, 'SurfArea'] = numpy.sum(AreaValues[I])
			outDF.loc[curStructIDX, 'ThickAvg'] = numpy.mean(ThicknessValues[I])
			outDF.loc[curStructIDX, 'ThickStd'] = numpy.std(ThicknessValues[I])
			outDF.loc[curStructIDX, 'MeanCurv'] = numpy.mean(numpy.abs(MeanCurvValues[I]) * AreaValues[I])
			outDF.loc[curStructIDX, 'GausCurv'] = numpy.mean(numpy.abs(GaussCurvValues[I]) * AreaValues[I])

			if True:
				area = AreaValues[I]
				k1 = K1CurvValues[I]
				k2 = K2CurvValues[I]
				PosGauss = GaussCurvValues[I] > 0
				if numpy.any(PosGauss):
					ici = numpy.sum(area[PosGauss] * GaussCurvValues[I[PosGauss]])
				else:
					ici = 0

				fi = numpy.sum(area * numpy.abs(k1) * (numpy.abs(k1) - numpy.abs(k2)))
				outDF.loc[curStructIDX, 'FoldInd'] = fi / (4 * numpy.pi)
				outDF.loc[curStructIDX, 'CurvInd'] = ici / (4 * numpy.pi)
	outDF.to_csv(os.path.join(SubjectsDir, SubjectID, 'stats', Hemi + "." + Atlas + ".stats"))

#
#			else:
#				pici = numpy.zeros(I.size)
#				pfi = numpy.zeros(I.size)
#
#				for curVertexIDX in range(I.size):
#					curNeighbours = vertexNeighbours[I[curVertexIDX]]
#
##    if (vertex->K > 0)
##    {
##      ici += area * (double)vertex->K ;
##    }
#					
#					PosGauss = GaussCurvValues[curNeighbours] > 0
#					if numpy.any(PosGauss):
#						ici = numpy.sum(AreaValues[curNeighbours[PosGauss]] * GaussCurvValues[curNeighbours[PosGauss]])
#					else:
#						ici = 0
#
##    fi += area * Kmax * (Kmax - Kmin) ;
#					fi = numpy.sum(AreaValues[curNeighbours] * numpy.abs(K2CurvValues[curNeighbours]) * (numpy.abs(K2CurvValues[curNeighbours]) - numpy.abs(K1CurvValues[curNeighbours])))
#					pici[curVertexIDX] = ici / (4 * numpy.pi)
#					pfi[curVertexIDX] = fi / (4 * numpy.pi)
#				# code in freesurfer will be folded in
#MRIScomputeCurvatureIndices(MRI_SURFACE *mris, double *pici, double *pfi)
#{
#  int    vno ;
#  VERTEX *vertex ;
#  double k1, k2, ici, fi, area, Kmax, Kmin ;
#
#  ici = fi = 0.0 ;
#  for (vno = 0 ; vno < mris->nvertices ; vno++)
#  {
#    vertex = &mris->vertices[vno] ;
#    if (vertex->ripflag)
#    {
#      continue ;
#    }
#    if (vno == Gdiag_no)
#    {
#      DiagBreak() ;
#    }
#    k1 = (double)vertex->k1 ;
#    k2 = (double)vertex->k2 ;
#    area = (double)vertex->area ;
#    if (vertex->K > 0)
#    {
#      ici += area * (double)vertex->K ;
#    }
#    Kmax = (double)fabs(k1) ;
#    Kmin = (double)fabs(k2) ;
#    fi += area * Kmax * (Kmax - Kmin) ;
#  }
#
#  *pfi = fi / (4.0*M_PI) ;
#  *pici = ici / (4.0 * M_PI) ;
#  return(NO_ERROR) ;
#}
#



#ASEGNII = nibabel.load(ASEGFileName)
#ASEGIMG = ASEGNII.get_data()
#
#NormNII = nibabel.load(NormFileName)
#NormIMG = NormNII.get_data()
#
#ASegLUT = pandas.read_table(
#			os.path.join(os.environ['FREESURFER_HOME'], 'ASegStatsLUT.txt'), comment='#', header=None, delim_whitespace=True, names=['Index', 'name', 'R', 'G', 'B', 'A'])
#
#outDFColumns = ['SegId', 'NVoxels', 'Volume_mm3', 'StructName', 'normMean', 'normStdDev', 'normMin', 'normMax', 'normRange']
#
#ExcludeSegId = [0, 2, 3, 41, 42]
#
#I = numpy.logical_not(ASegLUT.Index.isin(ExcludeSegId))
#ASegLUT = ASegLUT[I]
#
#outDF = pandas.DataFrame(columns = outDFColumns, index = ASegLUT.index)
#outDF.StructName = ASegLUT.name
#outDF.SegId = ASegLUT.Index
#
#for curLabelIDX in outDF.index:
#	curLabel = outDF.loc[curLabelIDX, 'SegId']
#	I = numpy.where(ASEGIMG == curLabel)
#	if I[0].size > 0:
#		outDF.loc[curLabelIDX, 'NVoxels'] = I[0].size
#		outDF.loc[curLabelIDX, 'Volume_mm3'] = I[0].size * numpy.prod(ASEGNII.header.get_zooms())
#		NormVoxelsInI = NormIMG[I]
#
#		outDF.loc[curLabelIDX, 'normMin'] = numpy.min(NormVoxelsInI)
#		outDF.loc[curLabelIDX, 'normMax'] = numpy.max(NormVoxelsInI)
#		outDF.loc[curLabelIDX, 'normMean'] = numpy.mean(NormVoxelsInI)
#		outDF.loc[curLabelIDX, 'normStdDev'] = numpy.mean(NormVoxelsInI)
#
#outDF.normRange = outDF.normMax - outDF.normMin
#NewASEGNII = nibabel.MGHImage(NewASEGIMG, ASEGNII.affine, ASEGNII.header)

#nibabel.save(NewASEGNII, sys.argv[3])
