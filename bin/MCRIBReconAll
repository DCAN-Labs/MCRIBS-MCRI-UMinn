#!/usr/bin/env python3

import os
import getopt
import sys

import subprocess

import argparse
import numpy

def runCommand(CMD):
	print("Running command:")
	print("\t" + " ".join(CMD))
	try:
		subprocess.check_call(CMD)
	except subprocess.CalledProcessError:
		print("Command Failed")
		quit()

def structN4DefaultOptions():
	return ['-v', '-c', '[100x100x100x100,0]', '-b', '[200]', '-s', '3']

def main():
	doProcessingSteps = dict.fromkeys(['conform', 'tissueseg', 'surfrecon'])

	argParser = argparse.ArgumentParser(description = "Performs MCRIB preprocessing and parcellation\n\nFor each <subject id>, input data are to be placed as follows:\n\tRawT2/<subject id>.nii.gz: Whole-brain T2-weighted image", usage = sys.argv[0] + " <processing directives> [processing options] <subject id>", formatter_class = argparse.RawTextHelpFormatter)

	conformArgGroup = argParser.add_argument_group('conform', "PROCESSING DIRECTIVE. Reorients to radiological, axial slice orientation. Resamples to isotropic voxels")
	conformArgGroup.add_argument('--conform', help = "PROCESSING DIRECTIVE", action = 'store_true')
	conformArgGroup.add_argument('--voxelsize', help = "Voxel size to use for isotropic resampling. Use \"volumepreserve\" to preserve original voxel volume", required = False, type = str, action = 'store', default = 'volumepreserve')
	
	tissueSegArgGroup = argParser.add_argument_group('tissueseg', "Perform tissue type segmentation, depends --conform")
	tissueSegArgGroup.add_argument('--tissueseg', help = "PROCESSING DIRECTIVE", required = False, action = 'store_true')
	tissueSegArgGroup.add_argument('--tissuesegmethod', help = "Specify tissue segmentation method", required = False, choices = ['DrawEM'], default = 'DrawEM')
	tissueSegArgGroup.add_argument('--subjectage', help = "Subject age in weeks", required = False, choices = numpy.arange(28, 45), default = 40)
	
	surfReconArgGroup = argParser.add_argument_group('surfrecon', 'Perform cortical surface extraction, depends --tissueseg')
	surfReconArgGroup.add_argument('--surfrecon', help = "PROCESSING DIRECTIVE", required = False, action = 'store_true')
	surfReconArgGroup.add_argument('--surfreconmethod', help = "Specify cortical surface extraction method", required = False, choices = ['Deformable'], default = 'Deformable')
	surfReconArgGroup.add_argument('--deformablejointhresh', help = "Join threshold parameter for Deformable", required = False, type = float, default = 1)
	
	inflateSphereArgGroup = argParser.add_argument_group('inflatesphere', 'Perform inflation, spherical mapping, curv, area, depends --surfrecon')
	inflateSphereArgGroup.add_argument('--inflatesphere', help = "PROCESSING DIRECTIVE", required = False, action = 'store_true')
	
	surfRegArgGroup = argParser.add_argument_group('surfreg', 'Perform surface registration to the spherical template, depends --surfrecon')
	surfRegArgGroup.add_argument('--surfreg', help = "PROCESSING DIRECTIVE", required = False, action = 'store_true')
	
	surfParcArgGroup = argParser.add_argument_group('cortparc', 'Perform cortical parcellation, depends on --surfreg')
	surfParcArgGroup.add_argument('--surfparc', help = "PROCESSING DIRECTIVE", required = False, action = 'store_true')
	surfParcArgGroup.add_argument('--surfparcatlas', help = "Parcellation scheme to use", required = False, choices = ['aparc', 'aparc+DKTatlas'], default = 'aparc+DKTatlas')

	argParser.add_argument('-openmp', '--openmp', help = "Number of threads for multithreading applications", required = False, type = int, default = 1)
	argParser.add_argument('-hemi', '--hemi', help = "Only process a single hemisphere", choices = ['lh', 'rh'], required = False)
	
	argParser.add_argument('subjectid', help = "The subject ID, must have RawT2/<subjectid>.nii.gz")

	options = argParser.parse_args()
	
	#argParser.print_help()
	print(vars(options))
	print(type(options.openmp))
	#quit()
	anyProcessingStep = False

	for curStep in doProcessingSteps.keys():
		if vars(options)[curStep]:
			anyProcessingStep = True
	
	#if anyProcessingStep == False:
	#	print("No processing steps specified")
	#	argParser.print_help()
	#	quit()

	if options.conform == True:
		cmd = ["MCRIBConform", os.path.join('RawT2', options.subjectid + ".nii.gz"), options.voxelsize, os.path.join('RawT2RadiologicalIsotropic', options.subjectid + ".nii.gz")]
		runCommand(cmd)
		#rint("--struct-reorient no longer needed, ignoring")
		pass
	
	if options.tissueseg == True:
		if options.tissuesegmethod == 'DrawEM':
			cmd = ["MCRIBTissueSegDrawEM", options.subjectid]
			runCommand(cmd)
		pass	
	
	if options.surfrecon == True:
		cmd = ["MCRIBSurfReconDeformable", options.subjectid, str(options.deformablejointhresh)]
		runCommand(cmd)
		pass
	
	if options.inflatesphere == True:
		cmd = ["MCRIBInflateSphere", options.subjectid]
		runCommand(cmd)
		pass
		
	quit()
	if doProcessingSteps['struct-neckcrop']:
		cmd = ["StructNeckCrop", subjectID]
		runCommand(cmd)
		pass
	
	if doProcessingSteps['struct-biascorrect']:
		N4Options = structN4DefaultOptions()
		if structBiasCorrectN4Options != None:
			N4Options.extend(structBiasCorrectN4Options)

		cmd = ["StructBiasCorrect", subjectID]
		cmd.extend(N4Options)
		#print cmd
		runCommand(cmd)
		pass
	
	if doProcessingSteps['struct-freesurfer']:

		cmd = ["StructFreesurfer", subjectID]
		if freesurferRun == True:
			cmd.append("--run")
		else:
			cmd.append("--no-run")

		if structFreesurferUseBiasCorrected == True:
			cmd.append("--biascorrected")
		else:
			cmd.append("--raw")

		if extraFreesurferOptions != None:
			cmd.extend(extraFreesurferOptions)

		runCommand(cmd)
		pass
	
	if doProcessingSteps['struct-skullstrip']:
		cmd = ["StructSkullStrip", subjectID, structSkullStripMethod]
		runCommand(cmd)
		pass
	
	if doProcessingSteps['struct-extractfreesurferbaselabels']:
		cmd = ["StructExtractFreesurferBaseLabels", subjectID, str(MrtrixVersionToUse)]
		if freesurferLongSubject != None:
			cmd.extend([freesurferLongSubject])
		runCommand(cmd)
		pass
	
	if doProcessingSteps['dwi-reorient']:
		#cmd = ["DWIReorient", subjectID]
		#runCommand(cmd)

		pass

	if doProcessingSteps['dwi-topup']:
		pass

	if doProcessingSteps['dwi-eddy']:
		pass

	if doProcessingSteps['dwi-savebzero']:
		cmd = ["DWISaveBZero", subjectID]
		if DWIUseEddy == True:
			cmd.append('--use-eddy')
		runCommand(cmd)
		pass

	if doProcessingSteps['dwi-skullstrip']:
		cmd = ["DWISkullStrip", subjectID]
		runCommand(cmd)
		pass
	
	if doProcessingSteps['dwi-distortioncorrect']:
		cmd = ["DWIDistortionCorrect", subjectID, DWIDistortionCorrectMethod]
		runCommand(cmd)
		pass
	
	if doProcessingSteps['dwi-regtostruct']:
		cmd = ["DWIRegToStruct", subjectID, DWIDistortionCorrectMethod]
		runCommand(cmd)
		pass

	if doProcessingSteps['dwi-mrtrixpreprocess']:
		
		#--mrtrix-no-struct-space: do not create structural space outputs", \
	#"\t\t\t--mrtrix-no-struct-linear: do not create structural space linear only outputs", \
	#"\t\t\t--mrtrix-no-nobrotation: do not create outputs that do not have rotated b-vectors", \
	#"", \

		
		if DWIUseEddy == True:
			MrtrixCommand = 'DWIMrtrixPreprocessMrtrixEddy'
			cmd = [MrtrixCommand, subjectID, 'mrtrixEddy', os.path.join('DWIEddy', subjectID + '.nii.gz'), os.path.join('DWISkullStripped', subjectID + "_mask.nii.gz"), os.path.join('DWIEddy', subjectID + ".eddy_rotated_bvecs"), os.path.join('RawDWI', subjectID + ".bval")]
			subprocess.call(cmd)
		else:
			MrtrixCommand = 'DWIMrtrixPreprocessMrtrix' + str(MrtrixVersionToUse)
			if MrtrixDWISpaceNoBRotation == True:
				cmd = [MrtrixCommand, subjectID, 'mrtrix' + str(MrtrixVersionToUse) + 'DWISpaceNoBReorient', os.path.join('DWIEddyCorrected', subjectID + '.nii.gz'), os.path.join('DWISkullStripped', subjectID + "_mask.nii.gz"), os.path.join('RawDWI', subjectID + ".grad")]
				if MrtrixCSDLMAX != None:
					cmd.append(MrtrixCSDLMAX)
				runCommand(cmd)
			
			if MrtrixDWISpaceBRotation == True:
				cmd = [MrtrixCommand, subjectID, 'mrtrix' + str(MrtrixVersionToUse) + 'DWISpaceBReorient', os.path.join('DWIEddyCorrected', subjectID + '.nii.gz'), os.path.join('DWISkullStripped', subjectID + "_mask.nii.gz"), os.path.join('DWIEddyCorrected', subjectID + '.grad')]
				if MrtrixCSDLMAX != None:
					cmd.append(MrtrixCSDLMAX)
				runCommand(cmd)

			if MrtrixT1SpaceNoBRotation == True:
				cmd = [MrtrixCommand, subjectID, 'mrtrix' + str(MrtrixVersionToUse) + 'StructSpaceNoBReorient', os.path.join('DWIRegToStruct', subjectID, 'dwi_ants_raw_reg.nii.gz'), os.path.join('T1SkullStripped', subjectID + "_mask.nii.gz"), os.path.join('RawDWI', subjectID + ".grad")]
				if MrtrixCSDLMAX != None:
					cmd.append(MrtrixCSDLMAX)
				runCommand(cmd)

#		if MrtrixNoStructSpace == False and MrtrixNoNoBRotation == False:
			if MrtrixT1SpaceNoBRotation == True:
				cmd = [MrtrixCommand, subjectID, 'mrtrix' + str(MrtrixVersionToUse) + 'StructSpaceBReorient', os.path.join('DWIRegToStruct', subjectID, 'dwi_ants_raw_reg.nii.gz'), os.path.join('T1SkullStripped', subjectID + "_mask.nii.gz"), os.path.join('DWIRegToStruct', subjectID, 'dwi_ants_raw_reg.grad')]
				if MrtrixCSDLMAX != None:
					cmd.append(MrtrixCSDLMAX)
				runCommand(cmd)
#		
#		#cmd = [MrtrixCommand, subjectID, 'mrtrix' + str(MrtrixVersionToUse) + 'T1SpaceNoEddyBReorient', os.path.join('DWIRegToStruct', subjectID, 'dwi_ants_raw_reg.nii.gz'), os.path.join('T1SkullStripped', subjectID + "_mask.nii.gz"), os.path.join('DWIRegToStruct', subjectID, 'linear_reg_no_eddy_reorient.grad')]
#		#runCommand(cmd)
#		
#		if MrtrixNoStructSpace == False and MrtrixNoStructLinear == False and MrtrixNoNoBRotation == False:
#			cmd = [MrtrixCommand, subjectID, 'mrtrix' + str(MrtrixVersionToUse) + 'T1LinearSpaceNoBReorient', os.path.join('DWIRegToStruct', subjectID, 'dwi_linear_raw_reg.nii.gz'), os.path.join('T1SkullStripped', subjectID + "_mask.nii.gz"), os.path.join('RawDWI', subjectID + ".grad")]
#			if MrtrixCSDLMAX != None:
#				cmd.append(MrtrixCSDLMAX)
#			runCommand(cmd)
#
#		if MrtrixNoStructSpace == False and MrtrixNoStructLinear == False and MrtrixNoNoBRotation == False:
#			cmd = [MrtrixCommand, subjectID, 'mrtrix' + str(MrtrixVersionToUse) + 'T1LinearSpaceBReorient', os.path.join('DWIRegToStruct', subjectID, 'dwi_linear_raw_reg.nii.gz'), os.path.join('T1SkullStripped', subjectID + "_mask.nii.gz"), os.path.join('DWIRegToStruct', subjectID, 'dwi_ants_raw_reg.grad')]
#			if MrtrixCSDLMAX != None:
#				cmd.append(MrtrixCSDLMAX)
#			runCommand(cmd)
#		#if MrtrixNoNoBRotation == False:

	#	cmd = [MrtrixCommand, subjectID, 'mrtrix' + str(MrtrixVersionToUse) + 'DWISpaceBReorient', os.path.join('DWIEddyCorrected', subjectID + '.nii.gz'), os.path.join('DWISkullStripped', subjectID + "_mask.nii.gz"), os.path.join('DWIRegToStruct', subjectID, 'dwi_eddy_reorient.grad')]
		
#		elif MrtrixVersionToUse == 3:
#			#cmd = ["DWIMrtrixPreprocessMrtrix3", subjectID, 'mrtrix3T1SpaceNoBReorient', os.path.join('DWIRegToStruct', subjectID, 'dwi_ants_raw_reg.nii.gz'), os.path.join('T1SkullStripped', subjectID + "_mask.nii.gz"), os.path.join('RawDWI', subjectID + ".grad")]
#			#runCommand(cmd)
#			cmd = ["DWIMrtrixPreprocessMrtrix3", subjectID, 'mrtrix3T1SpaceBReorient', os.path.join('DWIRegToStruct', subjectID, 'dwi_ants_raw_reg.nii.gz'), os.path.join('T1SkullStripped', subjectID + "_mask.nii.gz"), os.path.join('DWIRegToStruct', subjectID, 'dwi_ants_raw_reg.grad')]
#			runCommand(cmd)
#			#cmd = ["DWIMrtrixPreprocessMrtrix3", subjectID, 'mrtrix3T1SpaceNoEddyBReorient', os.path.join('DWIRegToStruct', subjectID, 'dwi_ants_raw_reg.nii.gz'), os.path.join('T1SkullStripped', subjectID + "_mask.nii.gz"), os.path.join('DWIRegToStruct', subjectID, 'linear_reg_no_eddy_reorient.grad')]
#			#runCommand(cmd)
#			
#			#cmd = ["DWIMrtrixPreprocessMrtrix3", subjectID, 'mrtrix3T1LinearSpaceNoBReorient', os.path.join('DWIRegToStruct', subjectID, 'dwi_linear_raw_reg.nii.gz'), os.path.join('T1SkullStripped', subjectID + "_mask.nii.gz"), os.path.join('RawDWI', subjectID + ".grad")]
#			#runCommand(cmd)
#			#cmd = ["DWIMrtrixPreprocessMrtrix3", subjectID, 'mrtrix3T1LinearSpaceBReorient', os.path.join('DWIRegToStruct', subjectID, 'dwi_linear_raw_reg.nii.gz'), os.path.join('T1SkullStripped', subjectID + "_mask.nii.gz"), os.path.join('DWIRegToStruct', subjectID, 'dwi_ants_raw_reg.grad')]
#			#runCommand(cmd)
#			cmd = ["DWIMrtrixPreprocessMrtrix3", subjectID, 'mrtrix3DWISpaceNoBReorient', os.path.join('DWIEddyCorrected', subjectID + '.nii.gz'), os.path.join('DWISkullStripped', subjectID + "_mask.nii.gz"), os.path.join('RawDWI', subjectID + ".grad")]
#			runCommand(cmd)
#			cmd = ["DWIMrtrixPreprocessMrtrix3", subjectID, 'mrtrix3DWISpaceBReorient', os.path.join('DWIEddyCorrected', subjectID + '.nii.gz'), os.path.join('DWISkullStripped', subjectID + "_mask.nii.gz"), os.path.join('DWIRegToStruct', subjectID, 'dwi_eddy_reorient.grad')]
#			runCommand(cmd)
#
#		pass
#	
#if doProcessingSteps['struct-regfreesurfertodwi']:
#		pass
	
	if doProcessingSteps['conn-generateseeds']:
		cmd = ["ConnGenerateSeeds", subjectID]
		if connSchemes != None:
			cmd.extend(connSchemes.split(','))
		runCommand(cmd)
		pass
#def main():

if __name__ == "__main__":
	main()
