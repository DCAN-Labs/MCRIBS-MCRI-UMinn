#!/usr/bin/env python3

import numpy
import sys
import os
import nibabel
import getopt

import scipy.ndimage
import scipy.cluster.vq

def ismember(A, B):
    return numpy.reshape(numpy.in1d(A.ravel(), numpy.array(B)), A.shape)


def replaceWMToLeftInBetweenLabels(labelImage, baseLabelToReplace):
    """Mask that replaces WM between left hemisphere baseLabelToReplace and right hemisphere baseLabelToReplace.

    Parameters
    ----------
    labelImage: numpy.ndarray
        Current label image.
    baseLabelToReplace: int
        The LH DKT label to replace.
    """
    
    leftMoveSE = numpy.reshape(numpy.array([1, 0, 0], dtype=numpy.bool_), [3, 1, 1])
    #labelToDilate = 1002
    
    T = numpy.logical_and(scipy.ndimage.binary_dilation(labelImage == baseLabelToReplace, structure=leftMoveSE), labelImage != baseLabelToReplace)

    R = numpy.zeros_like(T)
    
    if numpy.any(T):
        IDX = numpy.where(T)
    
        for z in range(IDX[0].size):
            
            allLabelsToLeft = labelImage[(numpy.arange(IDX[0][z], -1, -1), IDX[1][z], IDX[2][z])]
            # if there are no elements containing the current label to the left
            if numpy.all(allLabelsToLeft != baseLabelToReplace) and numpy.any(allLabelsToLeft == baseLabelToReplace + 1000):
                curRow = IDX[0][z]
                while curRow >= 0:
                    # if the label is WM then replace with 
                    if labelImage[(curRow, IDX[1][z], IDX[2][z])] == 2 or labelImage[(curRow, IDX[1][z], IDX[2][z])] == 41:
                        #labelImage[(curRow, IDX[1][z], IDX[2][z])] = 24
                        R[(curRow, IDX[1][z], IDX[2][z])] = 1
                    elif labelImage[(curRow, IDX[1][z], IDX[2][z])] >= 2000 and labelImage[(curRow, IDX[1][z], IDX[2][z])] <= 2035:
                        break
                    curRow = curRow - 1
    return R


def largestComponent(BW):
    if not numpy.any(BW):
        return BW
    else:
        L, numLabels = scipy.ndimage.label(BW)
        H = numpy.bincount(L[L > 0])
        return (L == numpy.argmax(H))



opts, args = getopt.getopt(sys.argv[1:], "vh", ['largeventricles'])

if len(args) != 1:
        print("The number of arguments must be 1")
        print(sys.argv[0] + " <subjid>")
        exit()

verbose = False
largeVentricles = False
for o, a in opts:
        if o == '-v':
                verbose = True
        if o == '--largeventricles':
                largeVentricles = True


# makes a CSF mask around the subcortical grey and ventricles

subjID = args[0]
TissueSegDir = os.environ['TISSUESEGDIR']

T2NII = nibabel.load(os.path.join(TissueSegDir, subjID, subjID + "_t2w_restore_brain_dn.nii.gz"))
T2IMG = T2NII.get_fdata()

DKTNII = nibabel.load(os.path.join(TissueSegDir, subjID, subjID + "_majority_dkt_skullstrip_reg.nii.gz"))
DKTIMG = numpy.int16(DKTNII.get_fdata())

BrainmaskNII = nibabel.load(os.path.join(TissueSegDir, subjID, subjID + "_brain_mask.nii.gz"))
BrainmaskIMG = (BrainmaskNII.get_fdata()) > 0

GMSEGLHNII = nibabel.load(os.path.join(TissueSegDir, subjID, subjID + "_segmentation_gm_sep_lh.nii.gz"))
GMSEGLHIMG = (GMSEGLHNII.get_fdata() > 0)
GMSEGRHNII = nibabel.load(os.path.join(TissueSegDir, subjID, subjID + "_segmentation_gm_sep_rh.nii.gz"))
GMSEGRHIMG = (GMSEGRHNII.get_fdata() > 0)

GMSEGIMG = numpy.logical_or(GMSEGLHIMG, GMSEGRHIMG)

del GMSEGLHNII
del GMSEGLHIMG
del GMSEGRHNII
del GMSEGRHIMG

if largeVentricles:
    # do a 4-class K-means 
    centroids, classes = scipy.cluster.vq.kmeans2(T2IMG[BrainmaskIMG], 4)

    II = numpy.argsort(centroids.ravel())
    S = numpy.zeros_like(II)
    #print(centroids)

    #print(II)
    S[II] = numpy.arange(II.size)
    #print(S)
    classes = S[classes]

    Atropos3IMG = numpy.zeros(T2IMG.shape, dtype = numpy.uint8)
    Atropos3IMG[BrainmaskIMG] = numpy.uint8(classes) + 1
    
    del centroids
    del classes
    NewNII = nibabel.Nifti1Image(numpy.uint8(Atropos3IMG), DKTNII.affine)
    nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_kmeans4.nii.gz"))

else:
    Atropos3NII = nibabel.load(os.path.join(TissueSegDir, subjID, subjID + "_t2w_restore_brain_dn_atropos3_priors_segmentation.nii.gz"))
    Atropos3IMG = numpy.uint8(Atropos3NII.get_fdata())

# laplacian 3, make the non-brain voxels bright

T = numpy.array(T2IMG)
T[BrainmaskIMG == 0] = 1000

DarkBandExclude = scipy.ndimage.gaussian_laplace(T, 1)
BrainmaskNoCerebellum = numpy.logical_and(BrainmaskIMG, numpy.logical_not(ismember(DKTIMG, [91, 93])))

#GPos = numpy.logical_and(numpy.logical_and(DarkBandExclude < 0, scipy.ndimage.binary_erosion(Atropos3IMG != 3)), scipy.ndimage.binary_erosion(BrainmaskNoCerebellum, iterations = 4))

GPos = numpy.logical_and(DarkBandExclude < 0, scipy.ndimage.binary_erosion(BrainmaskNoCerebellum, iterations = 4))
DarkBandExclude = numpy.logical_and(scipy.ndimage.binary_dilation(GMSEGIMG), DarkBandExclude > 0)
# voxels that are DarkBandExclude cant be CSF
# voxels that are DarkBandExclude and not brightest label class cant be WM

# CSF exclude
# bright voxels attached to the main WM component

# main WM component
mainWMComponent = numpy.logical_and(ismember(DKTIMG, [2, 41]), numpy.logical_not(DarkBandExclude))

# WM exclude
# GM exclude
if largeVentricles:
    L, numLabels = scipy.ndimage.label(numpy.logical_and(scipy.ndimage.binary_closing(Atropos3IMG == 2, iterations = 4), numpy.logical_not(GMSEGIMG)))
else:
    L, numLabels = scipy.ndimage.label(numpy.logical_and(scipy.ndimage.binary_dilation(Atropos3IMG == 2), numpy.logical_not(GMSEGIMG)))
overlappingLabels = numpy.unique(L[mainWMComponent])

WMNotCSF = largestComponent(scipy.ndimage.binary_erosion(ismember(L, overlappingLabels[overlappingLabels > 0])))

#NewNII = nibabel.Nifti1Image(numpy.uint8(WMNotCSF), DKTNII.affine)
#nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_gpos.nii.gz"))

# remove CSF and cerebellum
WMNotCSF = numpy.logical_and(WMNotCSF, numpy.logical_not(scipy.ndimage.binary_dilation(ismember(DKTIMG, [91, 93, 170, 24, 28, 60, 14, 15, 4, 43, 9, 48]))))

for z in range(20):
    WMNotCSF = numpy.logical_and(scipy.ndimage.binary_dilation(WMNotCSF), GPos)

WMNotCSF = numpy.logical_and(WMNotCSF, numpy.logical_not(scipy.ndimage.binary_dilation(ismember(DKTIMG, [91, 93, 170, 28, 60, 14, 15, 4, 43, 9, 48]))))
# fill in the bit between the subcortical grey
SubCortClosedToAdd = numpy.logical_and(scipy.ndimage.binary_closing(ismember(DKTIMG, [9, 12, 13, 11, 28, 18, 48, 50, 51, 52, 60]), iterations = 15), ismember(DKTIMG, [2, 41]))

# dilate outwards from the laterval ventricles
HippoLatVentToAdd = ismember(DKTIMG, [43, 63, 4, 31, 53, 17])

DKTMask = numpy.logical_and(ismember(DKTIMG, [2, 41]), numpy.logical_not(GMSEGIMG))

for z in range(15):
    HippoLatVentToAdd = numpy.logical_and(scipy.ndimage.binary_dilation(HippoLatVentToAdd), DKTMask)

WMNotCSF = numpy.logical_or(WMNotCSF, SubCortClosedToAdd)
WMNotCSF = numpy.logical_or(WMNotCSF, HippoLatVentToAdd)
# remove hippocampus
WMNotCSF = numpy.logical_and(WMNotCSF, numpy.logical_not(scipy.ndimage.binary_dilation(ismember(DKTIMG, [17, 53]))))
WMNotCSF = numpy.logical_and(WMNotCSF, numpy.logical_not(scipy.ndimage.binary_dilation(ismember(DKTIMG, [91, 93, 31, 63, 170, 28, 60, 14, 15, 11, 13, 12, 50, 51, 52, 4, 43, 9, 48]))))
if largeVentricles:
    WMNotCSF = numpy.logical_and(WMNotCSF, Atropos3IMG != 4)

WMNotCSF = largestComponent(WMNotCSF)

M = replaceWMToLeftInBetweenLabels(DKTIMG, 1002)
WMNotCSF[M] = False
M = replaceWMToLeftInBetweenLabels(DKTIMG, 1023)
WMNotCSF[M] = False
M = replaceWMToLeftInBetweenLabels(DKTIMG, 1010)
WMNotCSF[M] = False

M = replaceWMToLeftInBetweenLabels(DKTIMG, 1005)
WMNotCSF[M] = False
WMNotCSF = numpy.logical_and(WMNotCSF, scipy.ndimage.binary_erosion(BrainmaskIMG, iterations = 5))

DKTLHGM = numpy.logical_and(DKTIMG >= 1000, DKTIMG <= 1036)
DKTRHGM = numpy.logical_and(DKTIMG >= 2000, DKTIMG <= 2036)

DKTLHGMDT = scipy.ndimage.distance_transform_edt(numpy.logical_not(DKTLHGM))
DKTRHGMDT = scipy.ndimage.distance_transform_edt(numpy.logical_not(DKTRHGM))

outIMG = numpy.zeros(GMSEGIMG.shape, dtype = numpy.uint8)

# components of the WM class in the intensity segmentation that overlap with the main WM component cant be CSF
NewNII = nibabel.Nifti1Image(numpy.uint8(numpy.logical_and(DKTLHGMDT < DKTRHGMDT, WMNotCSF)), DKTNII.affine)
nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_segmentation_wm_sep_lh.nii.gz"))

NewNII = nibabel.Nifti1Image(numpy.uint8(numpy.logical_and(DKTLHGMDT > DKTRHGMDT, WMNotCSF)), DKTNII.affine)
nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_segmentation_wm_sep_rh.nii.gz"))

#NewNII = nibabel.Nifti1Image(numpy.uint8(GPos), DKTNII.affine)
#nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_gpos.nii.gz"))