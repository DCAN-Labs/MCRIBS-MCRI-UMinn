#!/usr/bin/env python3

import numpy
import sys
import os
import nibabel
import scipy.ndimage
import getopt


def CSFReplaceNearMainWM(LabelFusionIMG, NewLabelFusionIMG, labelToReplace):
    CSFLToReplace = numpy.zeros_like(LabelFusionIMG, dtype=numpy.bool_)

    L, numLabels = scipy.ndimage.label(NewLabelFusionIMG == labelToReplace)
    H = numpy.bincount(L[L > 0])
    largestComponentOfLabel = (L == numpy.argmax(H))

    L, numCSFLabels = scipy.ndimage.label(NewLabelFusionIMG == 24)
    CSFLLabels = L[L > 0]
    H = numpy.bincount(CSFLLabels)
    maxCSFLabel = numpy.argmax(H)
    #L[L == maxCSFLabel] = 0
    #return L
    allLIDX = numpy.where(L > 0)

    sortedAllLIDX = numpy.argsort(CSFLLabels)
    allLIDX = (allLIDX[0][sortedAllLIDX], allLIDX[1][sortedAllLIDX], allLIDX[2][sortedAllLIDX])
    D = numpy.concatenate((numpy.array([0]), numpy.where(numpy.diff(CSFLLabels[sortedAllLIDX]) != 0)[0] + 1, numpy.array([allLIDX[0].size])))
    for z in range(1, numCSFLabels):
        if z != maxCSFLabel:
            LIDX = (allLIDX[0][D[z - 1]:D[z]], allLIDX[1][D[z - 1]:D[z]], allLIDX[2][D[z - 1]:D[z]])
                
            V = largestComponentOfLabel[(numpy.maximum(LIDX[0] - 1, 0), LIDX[1], LIDX[2])]
            if numpy.any(V):
                CSFLToReplace[LIDX] = True
                continue
            del V

            V = largestComponentOfLabel[(numpy.minimum(LIDX[0] + 1, LabelFusionIMG.shape[0] - 1), LIDX[1], LIDX[2])]
            if numpy.any(V):
                CSFLToReplace[LIDX] = True
                continue

            del V

            V = largestComponentOfLabel[(LIDX[0], numpy.maximum(LIDX[1] - 1, 0), LIDX[2])]
            if numpy.any(V):
                CSFLToReplace[LIDX] = True
                continue
            del V

            V = largestComponentOfLabel[(LIDX[0], numpy.minimum(LIDX[1] + 1, LabelFusionIMG.shape[1] - 1), LIDX[2])]
            if numpy.any(V):
                CSFLToReplace[LIDX] = True
                continue
            del V

            V = largestComponentOfLabel[(LIDX[0], LIDX[1], numpy.maximum(LIDX[2] - 1, 0))]
            if numpy.any(V):
                CSFLToReplace[LIDX] = True
                continue
            del V

            V = largestComponentOfLabel[(LIDX[0], LIDX[1], numpy.minimum(LIDX[2] + 1, LabelFusionIMG.shape[2] - 1))]
            if numpy.any(V):
                CSFLToReplace[LIDX] = True
                continue
            del V
    return CSFLToReplace

# DrawEM CC method
# replaces connected components `labelToReplace` if they are surrounded by WM labels
def drawEMCSFReplaceWM(LabelFusionIMG, brainMask, labelToReplace):

    CSFLToReplace = numpy.zeros_like(LabelFusionIMG, dtype=numpy.int16)
    M = numpy.logical_and(LabelFusionIMG == labelToReplace, brainMask)
    
    if numpy.any(M):
        CSFL, numCSFLabels = scipy.ndimage.label(M)
        CSFLLabels = CSFL[M]
        H = numpy.bincount(CSFLLabels)
        MaxCSFLabel = numpy.argmax(H)

        allLIDX = numpy.where(M)
        # sort the labelled voxel so their labels are in order
        sortedAllLIDX = numpy.argsort(CSFLLabels)
        allLIDX = (allLIDX[0][sortedAllLIDX], allLIDX[1][sortedAllLIDX], allLIDX[2][sortedAllLIDX])
        D = numpy.concatenate((numpy.array([0]), numpy.where(numpy.diff(CSFLLabels[sortedAllLIDX]) != 0)[0] + 1, numpy.array([allLIDX[0].size])))
        #print(D)
        for z in range(1, numCSFLabels):
            if z != MaxCSFLabel:
                
                LIDX = (allLIDX[0][D[z - 1]:D[z]], allLIDX[1][D[z - 1]:D[z]], allLIDX[2][D[z - 1]:D[z]])
                
                CSFBorderCount = 0
                LHWMBorderCount = 0
                RHWMBorderCount = 0

                V = LabelFusionIMG[(numpy.maximum(LIDX[0] - 1, 0), LIDX[1], LIDX[2])]
                CSFBorderCount = CSFBorderCount + numpy.count_nonzero(V != labelToReplace)
                LHWMBorderCount = LHWMBorderCount + numpy.count_nonzero(V == 2)
                RHWMBorderCount = RHWMBorderCount + numpy.count_nonzero(V == 41)

                V = LabelFusionIMG[(numpy.minimum(LIDX[0] + 1, LabelFusionIMG.shape[0] - 1), LIDX[1], LIDX[2])]
                CSFBorderCount = CSFBorderCount + numpy.count_nonzero(V != labelToReplace)
                LHWMBorderCount = LHWMBorderCount + numpy.count_nonzero(V == 2)
                RHWMBorderCount = RHWMBorderCount + numpy.count_nonzero(V == 41)

                V = LabelFusionIMG[(LIDX[0], numpy.maximum(LIDX[1] - 1, 0), LIDX[2])]
                CSFBorderCount = CSFBorderCount + numpy.count_nonzero(V != labelToReplace)
                LHWMBorderCount = LHWMBorderCount + numpy.count_nonzero(V == 2)
                RHWMBorderCount = RHWMBorderCount + numpy.count_nonzero(V == 41)

                V = LabelFusionIMG[(LIDX[0], numpy.minimum(LIDX[1] + 1, LabelFusionIMG.shape[1] - 1), LIDX[2])]
                CSFBorderCount = CSFBorderCount + numpy.count_nonzero(V != labelToReplace)
                LHWMBorderCount = LHWMBorderCount + numpy.count_nonzero(V == 2)
                RHWMBorderCount = RHWMBorderCount + numpy.count_nonzero(V == 41)

                V = LabelFusionIMG[(LIDX[0], LIDX[1], numpy.maximum(LIDX[2] - 1, 0))]
                CSFBorderCount = CSFBorderCount + numpy.count_nonzero(V != labelToReplace)
                LHWMBorderCount = LHWMBorderCount + numpy.count_nonzero(V == 2)
                RHWMBorderCount = RHWMBorderCount + numpy.count_nonzero(V == 41)
                
                V = LabelFusionIMG[(LIDX[0], LIDX[1], numpy.minimum(LIDX[2] + 1, LabelFusionIMG.shape[2] - 1))]
                CSFBorderCount = CSFBorderCount + numpy.count_nonzero(V != labelToReplace)
                LHWMBorderCount = LHWMBorderCount + numpy.count_nonzero(V == 2)
                RHWMBorderCount = RHWMBorderCount + numpy.count_nonzero(V == 41)
                del V
                # LMask = (CSFL == z)
                # CSFInsideBoundaryMask = numpy.logical_and(LMask, numpy.logical_not(erode3DCross(LMask)))
                # CSFInsideBoundaryCount = numpy.count_nonzero(CSFInsideBoundaryMask)
                # CSFOutsideBoundaryMask = numpy.logical_and(numpy.logical_not(LMask), dilate3DCross(LMask))
                # BorderLHWMMask = numpy.logical_and(CSFOutsideBoundaryMask, NewLabelFusionIMG == 2)
                # BorderRHWMMask = numpy.logical_and(CSFOutsideBoundaryMask, NewLabelFusionIMG == 41)
                if CSFBorderCount / 2 < LHWMBorderCount:
                    CSFLToReplace[LIDX] = z
                elif CSFBorderCount / 2 < RHWMBorderCount:
                    CSFLToReplace[LIDX] = z
    return CSFLToReplace



def dilate3DCross(IMG):
    if not isinstance(IMG, numpy.ndarray):
        raise TypeError("IMG must be a numpy.ndarray")

    SE = numpy.atleast_3d(numpy.array([1, 1, 1], dtype=numpy.bool_))
    outIMG = scipy.ndimage.binary_dilation(IMG, structure=numpy.reshape(SE, [3, 1, 1]))
    outIMG = numpy.logical_or(outIMG, scipy.ndimage.binary_dilation(IMG, structure=numpy.reshape(SE, [1, 3, 1])))
    outIMG = numpy.logical_or(outIMG, scipy.ndimage.binary_dilation(IMG, structure=numpy.reshape(SE, [1, 1, 3])))

    return outIMG

def erode3DCross(IMG):
    return numpy.logical_not(dilate3DCross(numpy.logical_not(IMG)))

def replaceWMToLeftInBetweenAnyLabels(labelImage, leftLabelToReplace, rightLabelToReplace):
    """Mask that replaces WM between left hemisphere baseLabelToReplace and right hemisphere baseLabelToReplace.

    Parameters
    ----------
    labelImage: numpy.ndarray
        Current label image.
    leftLabelToReplace: int
        The LH DKT label to replace.
    """
    
    leftMoveSE = numpy.reshape(numpy.array([1, 0, 0], dtype=numpy.bool_), [3, 1, 1])
    #labelToDilate = 1002
    
    T = numpy.logical_and(scipy.ndimage.binary_dilation(labelImage == leftLabelToReplace, structure=leftMoveSE), labelImage != leftLabelToReplace)
    
    R = numpy.zeros(T.shape, dtype=numpy.bool_)
    
    if numpy.any(T):
        IDX = numpy.where(T)
    
        for z in range(IDX[0].size):
            
            allLabelsToLeft = labelImage[(numpy.arange(IDX[0][z], -1, -1), IDX[1][z], IDX[2][z])]
            # if there are no elements containing the current label to the left

            # if the base label is 1023, then ignore voxels that have another LH label to their left
            if numpy.all(allLabelsToLeft != leftLabelToReplace) and numpy.any(allLabelsToLeft == rightLabelToReplace):
                curRow = IDX[0][z]
                while curRow >= 0:
                    # if the label is WM then replace with 
                    if labelImage[(curRow, IDX[1][z], IDX[2][z])] == 24:
                        #labelImage[(curRow, IDX[1][z], IDX[2][z])] = 24
                        R[(curRow, IDX[1][z], IDX[2][z])] = True
                    elif labelImage[(curRow, IDX[1][z], IDX[2][z])] == rightLabelToReplace:
                        break
                    curRow = curRow - 1
    return R

                        
def replaceWMToLeftInBetweenDKTLabels(labelImage, baseLabelToReplace):
    """Mask that replaces WM between left hemisphere baseLabelToReplace and right hemisphere baseLabelToReplace.

    Parameters
    ----------
    labelImage: numpy.ndarray
        Current label image.
    baseLabelToReplace: int
        The LH DKT label to replace.
    """
    
    leftMoveSE = numpy.reshape(numpy.array([1, 0, 0], dtype=numpy.bool_), [3, 1, 1])
    #labelToDilate = 1002
    
    T = numpy.logical_and(scipy.ndimage.binary_dilation(labelImage == baseLabelToReplace, structure=leftMoveSE), labelImage != baseLabelToReplace)
    
    R = numpy.zeros(T.shape, dtype=numpy.bool_)
    
    if numpy.any(T):
        IDX = numpy.where(T)
    
        for z in range(IDX[0].size):
            
            allLabelsToLeft = labelImage[(numpy.arange(IDX[0][z], -1, -1), IDX[1][z], IDX[2][z])]
            # if there are no elements containing the current label to the left

            # if the base label is 1023, then ignore voxels that have another LH label to their left
            if baseLabelToReplace == 1023:
                if (numpy.all(allLabelsToLeft != baseLabelToReplace)
                    and numpy.any(allLabelsToLeft == baseLabelToReplace + 1000)
                    and numpy.all(numpy.logical_or(allLabelsToLeft < 1000, allLabelsToLeft >= 2000))
                    ):
                    curRow = IDX[0][z]
                    while curRow >= 0:
                        # if the label is WM then replace with 
                        if labelImage[(curRow, IDX[1][z], IDX[2][z])] == 2 or labelImage[(curRow, IDX[1][z], IDX[2][z])] == 41:
                            #labelImage[(curRow, IDX[1][z], IDX[2][z])] = 24
                            R[(curRow, IDX[1][z], IDX[2][z])] = True
                        elif labelImage[(curRow, IDX[1][z], IDX[2][z])] >= 2000 and labelImage[(curRow, IDX[1][z], IDX[2][z])] <= 2035:
                            break
                        curRow = curRow - 1
            else:
                if numpy.all(allLabelsToLeft != baseLabelToReplace) and numpy.any(allLabelsToLeft == baseLabelToReplace + 1000):
                    curRow = IDX[0][z]
                    while curRow >= 0:
                        # if the label is WM then replace with 
                        if labelImage[(curRow, IDX[1][z], IDX[2][z])] == 2 or labelImage[(curRow, IDX[1][z], IDX[2][z])] == 41:
                            #labelImage[(curRow, IDX[1][z], IDX[2][z])] = 24
                            R[(curRow, IDX[1][z], IDX[2][z])] = True
                        elif labelImage[(curRow, IDX[1][z], IDX[2][z])] >= 2000 and labelImage[(curRow, IDX[1][z], IDX[2][z])] <= 2035:
                            break
                        curRow = curRow - 1
            

    return R

def largestComponent(BW):
    if not numpy.any(BW):
        return BW
    else:
        L, numLabels = scipy.ndimage.label(BW)
        H = numpy.bincount(L[L > 0])
        return (L == numpy.argmax(H))

import Utils


def dilateWithMaskBarrier(BW, M, nDilate = 20):
    """
    Dilates BW nDilate iterations but makes sure to not go through the mask M.
    """

    BWDilated = numpy.logical_and(scipy.ndimage.binary_dilation(BW, iterations = nDilate), M)
    L, numLabels = scipy.ndimage.label(BWDilated)
    labelsInOriginal = numpy.unique(L[BW])
    return Utils.ismember(L, labelsInOriginal)

def maskInBetweenLabels(DKTIMG, labelA, labelB, nDilate=2, iterative_dilate=False):
    """Create a mask for the voxels "in between" two labels. Dilates the labels and then returns the voxels that overlap but not from the original labels."""
    
    if isinstance(labelA, list):
        labelAMask = Utils.ismember(DKTIMG, labelA)
    else:
        labelAMask = DKTIMG == labelA
    if isinstance(labelB, list):
        labelBMask = Utils.ismember(DKTIMG, labelB)
    else:
        labelBMask = DKTIMG == labelB

    if iterative_dilate:
        notLabelAMask = numpy.logical_not(labelAMask)
        notLabelBMask = numpy.logical_not(labelBMask)
        labelAMaskDilated = numpy.array(labelAMask)
        labelBMaskDilated = numpy.array(labelBMask)
        for z in range(nDilate):
            labelAMaskDilated = numpy.logical_and(scipy.ndimage.binary_dilation(labelAMaskDilated), notLabelBMask)
            labelBMaskDilated = numpy.logical_and(scipy.ndimage.binary_dilation(labelBMaskDilated), notLabelAMask)
    else:
        labelAMaskDilated = scipy.ndimage.binary_dilation(labelAMask, iterations = nDilate)
        labelBMaskDilated = scipy.ndimage.binary_dilation(labelBMask, iterations = nDilate)
    
    return numpy.logical_and(numpy.logical_and(labelAMaskDilated, labelBMaskDilated), numpy.logical_not(numpy.logical_or(labelAMask, labelBMask)))

if len(sys.argv) < 2:
    print("Usage: " + sys.argv[0] + " <subject id>")
    quit()

# fills midline WM labels for regions filling
# replaces small WM components with GM#
#@profile
def main():
        
    opts, args = getopt.getopt(sys.argv[1:], 'l', ['nowmlaplacianexpand'])

    largeVentricles = False
    WMLaplacianExpand = False
    for o, a in opts:
        if o == '-l':
            largeVentricles = True
        #if o == '--nowmlaplacianexpand':
        #    WMLaplacianExpand = False
    print("Using large ventricles: " + str(largeVentricles))
    #print("WMLaplacianExpand: " + str(WMLaplacianExpand))
    try:
        TissueSegDir = os.environ['TISSUESEGDIR']
    except Exception:
        TissueSegDir = 'TissueSegMCRIBS'

    subjID = args[0]

    if not os.path.isdir(os.path.join(TissueSegDir, subjID)):
        print("Tissue segmentation directory not found")
        quit()
    T2NII = nibabel.load(os.path.join(TissueSegDir, subjID, subjID + "_t2w_restore.nii.gz"))
    #T2IMG = numpy.single(T2NII.get_fdata())

    # OrigLabelFusionNII = nibabel.load(os.path.join(TissueSegDir, subjID, subjID + "_labelfusion_dkt.nii.gz"))
    # OrigLabelFusionNII = nibabel.load(os.path.join(TissueSegDir, subjID, subjID + "_labelfusion_dkt.nii.gz"))
    # OrigLabelFusionIMG = numpy.int16(OrigLabelFusionNII.get_fdata())

    writeAllIntermediate = True

    DrawEMNII = nibabel.load(os.path.join(TissueSegDir, subjID, subjID + "_drawem_alberts_tissueseg.nii.gz"))
    DrawEMIMG = numpy.squeeze(numpy.uint8(DrawEMNII.dataobj))

    LabelFusionNII = nibabel.load(os.path.join(TissueSegDir, subjID, subjID + "_labelfusion_dkt_edited.nii.gz"))
    LabelFusionIMG = numpy.int16(LabelFusionNII.dataobj)

    SegmentationGMNII = nibabel.load(os.path.join(TissueSegDir, subjID, subjID + "_segmentation_gm.nii.gz"))
    SegmentationGMIMG = numpy.array(SegmentationGMNII.dataobj) > 0

    BrainMaskNII = nibabel.load(os.path.join(TissueSegDir, subjID, subjID + "_brain_mask.nii.gz"))
    BrainMaskIMG = numpy.array(BrainMaskNII.dataobj) > 0

    # GradLapNII = nibabel.load(os.path.join(TissueSegDir, subjID, subjID + "_Lap.nii.gz"))
    # GradLapPosIMG = GradLapNII.get_fdata() > 0
    # del GradLapNII
    
    RibbonNII = nibabel.load(os.path.join(TissueSegDir, subjID, subjID + "_majority_dkt_ribbon_skullstrip_reg.nii.gz"))
    RibbonIMG = numpy.uint8(RibbonNII.dataobj)

    #GMSEGLHNII = nibabel.load(os.path.join(TissueSegDir, subjID, subjID + "_segmentation_gm_sep_lh.nii.gz"))
    #GMSEGLHIMG = (GMSEGLHNII.get_fdata() > 0)
    GMSEGLHIMG = numpy.logical_and(LabelFusionIMG >= 1000, LabelFusionIMG <= 1036)
    #GMSEGRHNII = nibabel.load(os.path.join(TissueSegDir, subjID, subjID + "_segmentation_gm_sep_rh.nii.gz"))
    #GMSEGRHIMG = (GMSEGRHNII.get_fdata() > 0)
    GMSEGRHIMG = numpy.logical_and(LabelFusionIMG >= 2000, LabelFusionIMG <= 2036)
    
    GMSEGIMG = numpy.logical_or(GMSEGLHIMG, GMSEGRHIMG)
    #GMSEGIMG = 
    #Atropos3NII = nibabel.load(os.path.join(TissueSegDir, subjID, subjID + "_t2w_restore_brain_dn_atropos3_priors_segmentation.nii.gz"))
    #Atropos3IMG = numpy.uint8(Atropos3NII.dataobj)
    
    #DarkWMNII = nibabel.load(os.path.join(TissueSegDir, subjID, subjID + "_dark_wm_bright_gm_to_remove.nii.gz"))
    #DarkWMIMG = numpy.logical_not(DarkWMNII.get_fdata() > 0)

    #BrightMaskNII = nibabel.load(os.path.join(TissueSegDir, subjID, subjID + "_dark_wm_bright_gm_to_remove.nii.gz"))
    #BrightMaskIMG = BrightMaskNII.get_fdata() > 0

    #Atropos3NII = nibabel.load(os.path.join(TissueSegDir, subjID, subjID + "_t2w_restore_brain_dn_majority_gm_segmentation.nii.gz"))
    #Atropos3IMG = numpy.uint8(Atropos3NII.get_fdata())

    # make a mask of all GM labels, both hemispheres
    GMMaskIMG = numpy.logical_or(Utils.ismember(LabelFusionIMG, [3, 42]), numpy.logical_and(LabelFusionIMG >= 1000, LabelFusionIMG <= 1035))
    GMMaskIMG = numpy.logical_or(GMMaskIMG, numpy.logical_and(LabelFusionIMG >= 2000, LabelFusionIMG <= 2035))

    # mask of cortical WM
    #WMMaskIMG = Utils.ismember(LabelFusionIMG, [2, 41])
    #CSFMaskIMG = (LabelFusionIMG == 24)
    #WMMaskIMG = Utils.ismember(LabelFusionIMG, [2, 41])
    #CSFMaskIMG = (LabelFusionIMG == 24)

    GMMaskIMGClosed = scipy.ndimage.binary_closing(GMMaskIMG, iterations = 3)

    # lateral ventricle, thalamus, caudate, putamen, hippocampus, choroid plexus, amygdala, accumbens, ventralDC
    
    # intersection between the ribbon WM and the label fusion WM and the subcortical grey
    # we want to find the voxels at the
    #RibbonWMLHDilated = numpy.logical_and(RibbonIMG == 2, numpy.logical_or(LHVoxelsToAdd, LabelFusionIMG == 2))
    #RibbonWMRHDilated = numpy.logical_and(RibbonIMG == 41, numpy.logical_or(RHVoxelsToAdd, LabelFusionIMG == 41))

    # dilate these masks constraining the dilation to avoid the GM
    #for z in range(3):
    #    RibbonWMLHDilated = numpy.logical_and(scipy.ndimage.binary_dilation(RibbonWMLHDilated, iterations = 1), numpy.logical_not(GMMaskIMGClosed))
    #    RibbonWMRHDilated = numpy.logical_and(scipy.ndimage.binary_dilation(RibbonWMRHDilated, iterations = 1), numpy.logical_not(GMMaskIMGClosed))

    # BoundaryRibbon is then the voxels in the neighbourhood of the midline intersection of the WM labels in the ribbon
    #BoundaryRibbon = numpy.logical_and(RibbonWMLHDilated, RibbonWMRHDilated)

    # these are the distance transforms of the distance between each voxel and the LH and RH cortical WM labels
    RibbonWMLHDT = scipy.ndimage.distance_transform_cdt(RibbonIMG != 2)
    RibbonWMRHDT = scipy.ndimage.distance_transform_cdt(RibbonIMG != 41)

    CloserToWMLHDT = RibbonWMLHDT < RibbonWMRHDT
    CloserToWMRHDT = numpy.logical_not(CloserToWMLHDT)
    #del RibbonWMLHDT
    #del RibbonWMRHDT

    
    #LHVentricleDilated = scipy.ndimage.binary_dilation(LabelFusionIMG == 4, iterations = 10)
    #RHVentricleDilated = scipy.ndimage.binary_dilation(LabelFusionIMG == 43, iterations = 10)

    #VentToAdd = numpy.logical_and(LHVentricleDilated, RHVentricleDilated)
    #VentToAdd[numpy.logical_or(LabelFusionIMG == 4, LabelFusionIMG == 43)] = False

    # replace the boundary voxels at the ribbon, 3rd ventricle, CC/Thalamus gap with WM labels from the ribbon
    NewLabelFusionIMG = numpy.array(LabelFusionIMG)
    #NewLabelFusionIMG[numpy.logical_and(BoundaryRibbon, CloserToWMLHDT)] = 2
    #NewLabelFusionIMG[numpy.logical_and(BoundaryRibbon, CloserToWMRHDT)] = 41
    NewLabelFusionIMG[numpy.logical_and(LabelFusionIMG == 14, CloserToWMLHDT)] = 2
    NewLabelFusionIMG[numpy.logical_and(LabelFusionIMG == 14, CloserToWMRHDT)] = 41

    # there are gaps between the CC and thalamus that we want to add to the WM labels
    CCAndThalamusIMG = Utils.ismember(LabelFusionIMG, [9, 48, 192])
    CCAndThalamusIMGClosed = scipy.ndimage.binary_closing(CCAndThalamusIMG, iterations = 25)
    # voxels added by the closing, so the gap between the CC and the thalamus
    CCAndThalamusIMGToAdd = numpy.logical_and(CCAndThalamusIMGClosed, numpy.logical_not(CCAndThalamusIMG))

    NewLabelFusionIMG[numpy.logical_and(CCAndThalamusIMGToAdd, CloserToWMLHDT)] = 2
    NewLabelFusionIMG[numpy.logical_and(CCAndThalamusIMGToAdd, CloserToWMRHDT)] = 41

    if writeAllIntermediate:
        NewNII = nibabel.Nifti1Image(numpy.int16(NewLabelFusionIMG), LabelFusionNII.affine)
        nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_intermediate_CCAndThalamusIMGToAdd.nii.gz"))
        
    #T = numpy.logical_and(numpy.logical_and(GradLapPosIMG, SegmentationGMIMG), Utils.ismember(NewLabelFusionIMG, [2, 41, 24]))
    #NewLabelFusionIMG[numpy.logical_and(T, CloserToWMLHDT)] = 1000
    #NewLabelFusionIMG[numpy.logical_and(T, CloserToWMRHDT)] = 2000
    #del T
    # fill in the midline
    # get transformed ribbon
    # remove labelfusion GM
    # get largest component
    # find voxels that are on the border between LH and RH WM in ribbon
    # add those to the new label fusion
    # fill holes on the WM labels
    #RibbonMidlineFillIMGClosed = scipy.ndimage.binary_closing(numpy.logical_or(RibbonMidlineFillIMG, LabelFusionIMG == 192), iterations = 5)
    #NewLabelFusionIMG[numpy.logical_and(RibbonMidlineFillIMGClosed, CloserToWMLHDT)] = 2
    #NewLabelFusionIMG[numpy.logical_and(RibbonMidlineFillIMGClosed, CloserToWMRHDT)] = 41

    #NewLabelFusionIMG[numpy.logical_and(VentToAdd, CloserToWMLHDT)] = 2
    #NewLabelFusionIMG[numpy.logical_and(VentToAdd, CloserToWMRHDT)] = 41
    
    # replace the subcortical grey structures with WM labels
    NewLabelFusionIMG[Utils.ismember(LabelFusionIMG, [4, 9, 28, 11, 12, 13, 17, 31, 18, 26])] = 2
    NewLabelFusionIMG[Utils.ismember(LabelFusionIMG, [51, 52, 43, 50, 60, 48, 54, 63, 53, 58])] = 41

    # replace WM labelled regions that have CSF intensity with CSF labels
    # label the brightest class of the 3-class atropos segmentation
    #L, numLabels = scipy.ndimage.label(Atropos3IMG == 3)
    ##H = numpy.bincount(L[L > 0])

    # retain regions that are at least 100 voxels
    #I = numpy.where(H > 100)[0]
    # R is a mask of the
    #LargeBrightRegionsInWM = numpy.logical_and(Utils.ismember(L, I), numpy.logical_or(LabelFusionIMG == 2, LabelFusionIMG == 41))

    #LateralVentriclesMask = Utils.ismember(LabelFusionIMG, [4, 43, 63, 31])
    # remove the lateral ventricles
    #M = numpy.logical_and(scipy.ndimage.binary_dilation(LargeBrightRegionsInWM), numpy.logical_not(scipy.ndimage.binary_dilation(LateralVentriclesMask)))
    # remove the bright mask
    #M = numpy.logical_and(M, numpy.logical_not(scipy.ndimage.binary_dilation(BrightMaskIMG)))

    #NewLabelFusionIMG[M] = 24

    #G = scipy.ndimage.gaussian_laplace(T2IMG, 1)
    #T = numpy.logical_and(NewLabelFusionIMG == 2, numpy.logical_not(numpy.logical_or(GMSEGIMG, G >= 0)))

    # fix for cortex near ventricles
    #GMNearVentDilated = scipy.ndimage.binary_dilation(Utils.ismember(NewLabelFusionIMG, [1021, 2021, 1010, 2010]), iterations = 5)
    #LatVentDilated = scipy.ndimage.binary_dilation(Utils.ismember(LabelFusionIMG, [4, 43]), iterations = 5)
    #NearLatVentToAdd = numpy.logical_and(numpy.logical_and(GMNearVentDilated, LatVentDilated), G >= 0)
    #T = numpy.logical_and(T, numpy.logical_not(NearLatVentToAdd))
    #NewNII = nibabel.Nifti1Image(numpy.int16(NewLabelFusionIMG), LabelFusionNII.affine)
    #nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_before_smallwm.nii.gz"))

    #NewNII = nibabel.Nifti1Image(numpy.uint8(NearLatVentToAdd), LabelFusionNII.affine)
    #nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_near_latvent_to_add.nii.gz"))
    #NewNII = nibabel.Nifti1Image(numpy.uint8(LatVentDilated), LabelFusionNII.affine)
    #nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_latvent_dilated.nii.gz"))

    #L, numLabels = scipy.ndimage.label(T)

    #if numLabels >= 1:
    #    N = numpy.bincount(L[L > 0])
    #    NewLabelFusionIMG[numpy.logical_and(L != numpy.argmax(N), L > 0)] = 1000

    #T = numpy.logical_and(NewLabelFusionIMG == 41, numpy.logical_not(GMSEGIMG))
    #T = numpy.logical_and(T, numpy.logical_not(NearLatVentToAdd))
    #L, numLabels = scipy.ndimage.label(T)

    #if numLabels >= 1:
    #    N = numpy.bincount(L[L > 0])
    #    NewLabelFusionIMG[numpy.logical_and(L != numpy.argmax(N), L > 0)] = 2000

    # GM voxels near the pericalcarine GM regions and near the laterval ventricles will often get mislabelled as WM
    

    #allDKTNII = nibabel.load(os.path.join(TissueSegDir, subjID, 'all_dkt_to_' + subjID + '.nii.gz'))
    #allDKTNII = nibabel.load(os.path.join(TissueSegDir, subjID, 'all_dkt_to_' + subjID + '.nii.gz'))
    #allDKTIMG = numpy.int16(allDKTNII.get_fdata())
    # change to read the transformed volumes individually    
    # only do this if we arent doing large ventricles
    # if largeVentricles == False:
    #     allDKTIMG = []
    #     for z in range(10):
    #         zStr = str(z + 1).zfill(2)
    #         curNII = nibabel.load(os.path.join(TissueSegDir, subjID, 'P' + zStr + '_dkt_with_skull_label_to_' + subjID + '.nii.gz'))
    #         curNII = nibabel.load(os.path.join(TissueSegDir, subjID, 'P' + zStr + '_dkt_with_skull_label_to_' + subjID + '.nii.gz'))
    #         allDKTIMG.append(numpy.int16(curNII.get_fdata()))
    #         del curNII
    #     allDKTIMG = numpy.stack(allDKTIMG, axis = 3)
    #     # find high probability of LH pericalcarine cortex from all the registered training images
    #     allLHPericalcarineMask = numpy.mean(numpy.single(allDKTIMG == 1021), axis = 3) >= 0.4
    #     allRHPericalcarineMask = numpy.mean(numpy.single(allDKTIMG == 2021), axis = 3) >= 0.4
    #     del allDKTIMG
    #     #del allDKTNII

    #     # all LH GM labels that aren't pericalcarine
    #     allLHGMNotPericalcarine = numpy.logical_not(scipy.ndimage.binary_dilation(numpy.logical_and(numpy.logical_and(LabelFusionIMG >= 1000, LabelFusionIMG <= 1035), LabelFusionIMG != 1021)))
    #     #NewNII = nibabel.Nifti1Image(numpy.uint8(allLHGMNotPericalcarine), LabelFusionNII.affine)
    #     #nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_lh_notpericalicarine.nii.gz"))

    #     # dilate the pericalcarine mask within the GM class of the atropos segmentation, not into other GM or the dark WM voxels
    #     T = allLHPericalcarineMask
    #     #maskForThisLoop = numpy.logical_and(numpy.logical_and(numpy.logical_and(Atropos3IMG == 1, LabelFusionIMG == 2), allLHGMNotPericalcarine), DarkWMIMG)
    #     maskForThisLoop = numpy.logical_and(numpy.logical_and(Atropos3IMG == 1, LabelFusionIMG == 2), allLHGMNotPericalcarine)
    #     for z in range(20):
    #         oldT = numpy.array(T)
    #         T = numpy.logical_and(scipy.ndimage.binary_dilation(T, iterations = 1), maskForThisLoop)
    #         if numpy.array_equal(T, oldT):
    #             break
    #     #T = dilateWithMaskBarrier(allLHPericalcarineMask, maskForThisLoop, 20)
    #     # replace the dilated voxels in the WM with the LH "unknown" cortex label
    #     T = scipy.ndimage.binary_closing(numpy.logical_or(allLHPericalcarineMask, T), iterations = 2)
        
    #     #NewNII = nibabel.Nifti1Image(numpy.uint8(numpy.logical_and(numpy.logical_and(numpy.logical_not(allLHPericalcarineMask), T), allLHGMNotPericalcarine)), LabelFusionNII.affine)
    #     #nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_labelfusion_regions_tt.nii.gz"))
    #     #nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_labelfusion_regions_tt.nii.gz"))

    #     NewLabelFusionIMG[numpy.logical_and(numpy.logical_and(numpy.logical_not(allLHPericalcarineMask), T), allLHGMNotPericalcarine)] = 1000

    #     # all RH GM labels that aren't pericalcarine
    #     allRHGMNotPericalcarine = numpy.logical_not(scipy.ndimage.binary_dilation(numpy.logical_and(numpy.logical_and(LabelFusionIMG >= 2000, LabelFusionIMG <= 2035), LabelFusionIMG != 2021)))

    #     # dilate the pericalcarine mask within the GM class of the atropos segmentation, not into other GM or the dark WM voxels
    #     #T = allRHPericalcarineMask
    #     #maskForThisLoop = numpy.logical_and(numpy.logical_and(numpy.logical_and(Atropos3IMG == 1, LabelFusionIMG == 2), allRHGMNotPericalcarine), DarkWMIMG)
    #     maskForThisLoop = numpy.logical_and(numpy.logical_and(Atropos3IMG == 1, LabelFusionIMG == 2), allRHGMNotPericalcarine)
    #     for z in range(20):
    #         oldT = numpy.array(T)
    #         T = numpy.logical_and(scipy.ndimage.binary_dilation(T, iterations = 1), maskForThisLoop)
    #         if numpy.array_equal(T, oldT):
    #             break
    #     #T = dilateWithMaskBarrier(allRHPericalcarineMask, numpy.logical_not(maskForThisLoop), 20)
    #     del maskForThisLoop

    #     T = scipy.ndimage.binary_closing(numpy.logical_or(allRHPericalcarineMask, T), iterations = 2)
    #     NewLabelFusionIMG[numpy.logical_and(numpy.logical_and(numpy.logical_not(allRHPericalcarineMask), T), allRHGMNotPericalcarine)] = 2000

    LatVentsDilated = scipy.ndimage.binary_dilation(Utils.ismember(LabelFusionIMG, [4, 43]), iterations = 5)

    # fill in small gaps between the pericalcarine label and voxels that were changed to 1000 near the lateral ventricles, change to 1000
    # T = Utils.ismember(NewLabelFusionIMG, [1021, 1000])
    # S = scipy.ndimage.binary_closing(T, iterations = 2)
    # NewLabelFusionIMG[numpy.logical_and(numpy.logical_and(numpy.logical_and(S, numpy.logical_not(T)), Utils.ismember(NewLabelFusionIMG, [2, 24])), LatVentsDilated)] = 1000

    # fill in small gaps between the pericalcarine label and voxels that were changed to 2000 near the lateral ventricles, change to 2000
    # T = Utils.ismember(NewLabelFusionIMG, [2021, 2000])
    # S = scipy.ndimage.binary_closing(T, iterations = 2)
    # NewLabelFusionIMG[numpy.logical_and(numpy.logical_and(numpy.logical_and(S, numpy.logical_not(T)), Utils.ismember(NewLabelFusionIMG, [41, 24])), LatVentsDilated)] = 2000

    if writeAllIntermediate:
        NewNII = nibabel.Nifti1Image(numpy.int16(NewLabelFusionIMG), LabelFusionNII.affine)
        nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_intermediate_UnknownAdd.nii.gz"))
        

    LHVentLargest = largestComponent(Utils.ismember(LabelFusionIMG, [4, 31]))
    RHVentLargest = largestComponent(Utils.ismember(LabelFusionIMG, [43, 63]))
    # #RHVentNotLargest = numpy.logical_and(L > 0, L != numpy.argmax(H))
    #RHVentNotLargest = numpy.logical_and(L > 0, L != numpy.argmax(H))

    LHVentLargestDilated = numpy.array(LHVentLargest)
    
    SS = LabelFusionIMG == 2
    for z in range(3):
        LHVentLargestDilated = numpy.logical_and(scipy.ndimage.binary_dilation(LHVentLargestDilated, iterations = 2), SS)
    
    RHVentLargestDilated = numpy.array(RHVentLargest)
    SS = LabelFusionIMG == 41
    for z in range(3):
        RHVentLargestDilated = numpy.logical_and(scipy.ndimage.binary_dilation(RHVentLargestDilated, iterations = 2), SS)
    del SS

    # fill holes in the WM labels
    T = scipy.ndimage.binary_fill_holes(NewLabelFusionIMG == 2)
    NewLabelFusionIMG[T] = 2
    T = scipy.ndimage.binary_fill_holes(NewLabelFusionIMG == 41)
    NewLabelFusionIMG[T] = 41
    del T
    
    if writeAllIntermediate:
        NewNII = nibabel.Nifti1Image(numpy.int16(NewLabelFusionIMG), LabelFusionNII.affine)
        nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_intermediate_holefill.nii.gz"))

    DrawEMIMGCSFDilated = scipy.ndimage.binary_dilation(DrawEMIMG == 1)

    T = numpy.logical_and(NewLabelFusionIMG == 41, numpy.logical_not(SegmentationGMIMG))
    L, numLabels = scipy.ndimage.label(T)
    NewLabelFusionIMG[numpy.logical_and(numpy.logical_and(L != numpy.argmax(numpy.bincount(L[L > 0])), NewLabelFusionIMG == 41), T)] = 24

    NewLabelFusionIMG[numpy.logical_and(L != numpy.argmax(numpy.bincount(L[L > 0])), NewLabelFusionIMG == 41)] = 24
    #NewLabelFusionIMG[numpy.logical_and(L != numpy.argmax(numpy.bincount(L[L > 0])), numpy.logical_and(NewLabelFusionIMG == 41, Atropos3IMG == 3))] = 24
    # NewNII = nibabel.Nifti1Image(numpy.int16(L), LabelFusionNII.affine)
    # nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_labelsright.nii.gz"))
    T = numpy.logical_and(NewLabelFusionIMG == 2, numpy.logical_not(SegmentationGMIMG))
    L, numLabels = scipy.ndimage.label(T)
    NewLabelFusionIMG[numpy.logical_and(numpy.logical_and(L != numpy.argmax(numpy.bincount(L[L > 0])), NewLabelFusionIMG == 2), T)] = 24

    if writeAllIntermediate:
        NewNII = nibabel.Nifti1Image(numpy.int16(NewLabelFusionIMG), LabelFusionNII.affine)
        nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_intermediate_drawemcsfdilate.nii.gz"))


    # NewNII = nibabel.Nifti1Image(numpy.int16(L), LabelFusionNII.affine)
    # nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_labelsleft.nii.gz"))
    NewLabelFusionIMG[numpy.logical_and(L != numpy.argmax(numpy.bincount(L[L > 0])), NewLabelFusionIMG == 2)] = 24
    #NewLabelFusionIMG[numpy.logical_and(L != numpy.argmax(numpy.bincount(L[L > 0])), numpy.logical_and(NewLabelFusionIMG == 2, DrawEMIMGCSFDilated))] = 24

    # replace really internal WM regions with DrawEM CSF
    BrainMaskIMGDT = scipy.ndimage.distance_transform_edt(BrainMaskIMG, sampling=BrainMaskNII.header.get_zooms())

    NewLabelFusionIMG[numpy.logical_and(BrainMaskIMGDT > 6, DrawEMIMGCSFDilated)] = 24

    NewLabelFusionIMG[LabelFusionIMG == 91] = 91
    NewLabelFusionIMG[LabelFusionIMG == 93] = 93
    NewLabelFusionIMG[LabelFusionIMG == 94] = 94
    NewLabelFusionIMG[LabelFusionIMG == 76] = 76

    T = numpy.array(NewLabelFusionIMG)
    T[SegmentationGMIMG] = 0
    CSFLHToReplace = CSFReplaceNearMainWM(LabelFusionIMG, T, 2)
    CSFRHToReplace = CSFReplaceNearMainWM(LabelFusionIMG, T, 41)
    
    NewLabelFusionIMG[CSFLHToReplace] = 2
    NewLabelFusionIMG[CSFRHToReplace] = 41

    del T
    del CSFLHToReplace
    del CSFRHToReplace
        
    # remove WM inbetween insula and neighbours, replace with CSF
    # insula and precentral 
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 1035, 1024)] = 999
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 2035, 2024)] = 999
    # insula and postcentral 
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 1035, 1022)] = 999
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 2035, 2022)] = 999
    # insula and transverse temporal
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 1035, 1034)] = 24
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 2035, 2034)] = 24
    # postcentral and transverse temporal
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 1022, 1034)] = 24
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 2022, 2034)] = 24
    # postcentral and superior temporal
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 1022, 1030)] = 24
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 2010, 2013)] = 24
    # superior temporal and middle temporal 
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 1015, 1030)] = 24
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 2015, 2030)] = 24
    # insula and superior temporal
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 1035, 1030)] = 24
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 2035, 2030)] = 24
    # pericalcarine and cuneus
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 1005, 1021)] = 24
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 2005, 2021)] = 24
    # precuneus and cuneus
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 1005, 1025)] = 24
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 2005, 2025)] = 24
    # precentral and postcentral
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 1022, 1024)] = 24
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 2022, 2024)] = 24

    # isthmus and cuneus
    #NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 1010, 1025)] = 24
    #NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 2010, 2025)] = 24

    # cuneus and superior parietal
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 1005, 1029)] = 24
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 2005, 2029)] = 24

    # cuneus and superior parietal
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 1008, 1029)] = 24
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 2008, 2029)] = 24
    
    # insula and pars opercularis
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 1018, 1035)] = 24
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 2018, 2035)] = 24
    
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 1018, 1024)] = 24
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 2018, 2024)] = 24
    
    # pars triangularis and RMF
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 1020, 1027)] = 24
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 2020, 2027)] = 24

    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 1030, 1031)] = 999
    
    nDilate = int(3.0 / numpy.mean(T2NII.header.get_zooms()))
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 1025, 1005, nDilate=nDilate, iterative_dilate=True)] = 24
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 2025, 2005, nDilate=nDilate, iterative_dilate=True)] = 24

    # lingual and isthmus
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 1010, 1013, nDilate=nDilate, iterative_dilate=True)] = 24
    NewLabelFusionIMG[maskInBetweenLabels(NewLabelFusionIMG, 2010, 2013, nDilate=nDilate, iterative_dilate=True)] = 24

    # fill in DrawEM CSF near pericalcarine
    NewLabelFusionIMG[numpy.logical_and(DrawEMIMG == 1, scipy.ndimage.binary_closing(Utils.ismember(NewLabelFusionIMG, [1021, 2021]), iterations=nDilate))] = 24

    NewLabelFusionIMG[LabelFusionIMG == 254] = 2
    NewLabelFusionIMG[LabelFusionIMG == 255] = 41
    NewLabelFusionIMG[LabelFusionIMG == 258] = 1000

    # restore the lateral ventricles
    NewLabelFusionIMG[Utils.ismember(LabelFusionIMG, [4, 31])] = 4
    NewLabelFusionIMG[Utils.ismember(LabelFusionIMG, [43, 63])] = 31

    NewLabelFusionIMG[LabelFusionIMG == 93] = 93

    #NewNII = nibabel.Nifti1Image(numpy.single(G), LabelFusionNII.affine)
    #nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_t2w_restore_laplacian2.nii.gz"))

    # fill the interhemispheric part between labels 1002 and 2002 by changing the runs of WM voxels to CSF
    
    M = replaceWMToLeftInBetweenDKTLabels(NewLabelFusionIMG, 1002)
    NewLabelFusionIMG[M] = 24

    # del H
    M = replaceWMToLeftInBetweenDKTLabels(NewLabelFusionIMG, 1023)
    NewLabelFusionIMG[M] = 24
    #M = replaceWMToLeftInBetweenDKTLabels(NewLabelFusionIMG, 1010)
    #NewLabelFusionIMG[M] = 24
    
    R = replaceWMToLeftInBetweenAnyLabels(LabelFusionIMG, 28, 60)
    #print(R)
    NewLabelFusionIMG[numpy.logical_and(R, CloserToWMLHDT)] = 2
    NewLabelFusionIMG[numpy.logical_and(R, CloserToWMRHDT)] = 41
    NewLabelFusionIMG[LabelFusionIMG == 28] = 2
    NewLabelFusionIMG[LabelFusionIMG == 60] = 41
    # NewLabelFusionIMG[Utils.ismember(LabelFusionIMG, [4, 9, 28, 11, 12, 13, 17, 31, 18, 26])] = 2
    # NewLabelFusionIMG[Utils.ismember(LabelFusionIMG, [51, 52, 43, 50, 60, 48, 54, 63, 53, 58])] = 41
    #RHVoxelsToAdd = Utils.ismember(LabelFusionIMG, [51, 52, 50, 60, 48, 54, 53, 58])

    # the region in between the ventricles where the septums are, close the ventricles and fill in with WM,
    # deprecated because it fills in cortical areas
    #VentClosed = scipy.ndimage.binary_closing(Utils.ismember(NewLabelFusionIMG, [4, 31]), iterations = 25)
    VentClosed = scipy.ndimage.binary_closing(Utils.ismember(NewLabelFusionIMG, [4, 31]), iterations = 25)
    #NewLabelFusionIMG[numpy.logical_and(numpy.logical_and(VentClosed, CloserToWMLHDT), NewLabelFusionIMG != 4)] = 2
    #NewLabelFusionIMG[numpy.logical_and(numpy.logical_and(VentClosed, CloserToWMRHDT), NewLabelFusionIMG != 31)] = 41

    LHVentDT = scipy.ndimage.distance_transform_edt(NewLabelFusionIMG != 4, sampling=T2NII.header.get_zooms())
    RHVentDT = scipy.ndimage.distance_transform_edt(NewLabelFusionIMG != 31, sampling=T2NII.header.get_zooms())

    # NewNII = nibabel.Nifti1Image(numpy.single(LHVentDT), LabelFusionNII.affine)
    # nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_LHVentDT.nii.gz"))

    # NewNII = nibabel.Nifti1Image(numpy.single(RHVentDT), LabelFusionNII.affine)
    # nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_RHVentDT.nii.gz"))

    VentFillMask = numpy.logical_and(numpy.logical_and(LHVentDT < 4, RHVentDT < 4), Utils.ismember(DrawEMIMG, [1, 5, 7]))
    
    NewLabelFusionIMG[numpy.logical_and(numpy.logical_and(VentFillMask, CloserToWMRHDT), NewLabelFusionIMG != 31)] = 41
    NewLabelFusionIMG[numpy.logical_and(numpy.logical_and(VentFillMask, CloserToWMLHDT), NewLabelFusionIMG != 4)] = 2
    # NewNII = nibabel.Nifti1Image(numpy.uint8(LHVentFillMask), LabelFusionNII.affine)
    # nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_LHVentFillMask.nii.gz"))
    
    NewLabelFusionIMG[scipy.ndimage.binary_dilation(LabelFusionIMG == 192)] = 192

    WMLHDilated = numpy.logical_and(scipy.ndimage.binary_dilation(NewLabelFusionIMG == 2, iterations=2), numpy.logical_not(GMMaskIMGClosed))
    WMRHDilated = numpy.logical_and(scipy.ndimage.binary_dilation(NewLabelFusionIMG == 41, iterations=2), numpy.logical_not(GMMaskIMGClosed))

    WMBoundaryClosed = scipy.ndimage.binary_closing(numpy.logical_and(WMRHDilated, WMLHDilated), iterations=5)

    T = numpy.logical_or(Utils.ismember(NewLabelFusionIMG, [2, 31, 41, 4, 192]), WMBoundaryClosed)
    V = scipy.ndimage.binary_fill_holes(T)
    Vadded = numpy.logical_and(V, numpy.logical_not(T))
    #NewNII = nibabel.Nifti1Image(numpy.uint8(V), LabelFusionNII.affine)
    #nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_V.nii.gz"))

    NewLabelFusionIMG[numpy.logical_and(Vadded, CloserToWMLHDT)] = 2
    NewLabelFusionIMG[numpy.logical_and(Vadded, CloserToWMRHDT)] = 41
    
    # do this again to really close off
    WMLHDilated = numpy.logical_and(scipy.ndimage.binary_dilation(NewLabelFusionIMG == 2, iterations=2), numpy.logical_not(GMMaskIMGClosed))
    WMRHDilated = numpy.logical_and(scipy.ndimage.binary_dilation(NewLabelFusionIMG == 41, iterations=2), numpy.logical_not(GMMaskIMGClosed))
    
    WMBoundaryClosed = scipy.ndimage.binary_dilation(numpy.logical_and(WMRHDilated, WMLHDilated), iterations=5)
    WMBoundaryClosed = scipy.ndimage.binary_erosion(WMBoundaryClosed, iterations=4)
    Vadded = numpy.logical_and(WMBoundaryClosed, Utils.ismember(NewLabelFusionIMG, [0, 24]))
    NewLabelFusionIMG[numpy.logical_and(Vadded, CloserToWMLHDT)] = 2
    NewLabelFusionIMG[numpy.logical_and(Vadded, CloserToWMRHDT)] = 41
    
    # restore CC 
    NewLabelFusionIMG[scipy.ndimage.binary_dilation(LabelFusionIMG == 192)] = 192

    #V = scipy.ndimage.binary_closing(Utils.ismember(NewLabelFusionIMG, [4, ]))
    
    #NewNII = nibabel.Nifti1Image(numpy.uint8(WMBoundaryClosed), LabelFusionNII.affine)
    #nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_V.nii.gz"))

    #leftMoveSE = numpy.reshape(numpy.array([1, 1, 0], dtype=numpy.bool_), [3, 1, 1])
    #rightMoveSE = numpy.reshape(numpy.array([0, 1, 1], dtype=numpy.bool_), [3, 1, 1])

    # NotGMMaskIMGClosed = numpy.logical_not(GMMaskIMGClosed)
    
    # dilatedL = Utils.ismember(NewLabelFusionIMG, [2, 4, 41, 31])
    
    # for z in range(15):
    #     dilatedL = numpy.logical_and(scipy.ndimage.binary_dilation(dilatedL), NotGMMaskIMGClosed)
    
    # T = numpy.logical_and(LeftDilatedRHWM, RightDilatedRHWM)
    # NewLabelFusionIMG[numpy.logical_and(numpy.logical_and(T, CloserToWMRHDT), numpy.logical_not(Utils.ismember(NewLabelFusionIMG, [41, 31])))] = 41
    # NewLabelFusionIMG[numpy.logical_and(numpy.logical_and(T, CloserToWMRHDT), numpy.logical_not(Utils.ismember(NewLabelFusionIMG, [41, 31])))] = 41
    # # NewNII = nibabel.Nifti1Image(numpy.uint8(R), LabelFusionNII.affine)
    # nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_R.nii.gz"))
    # NewNII = nibabel.Nifti1Image(numpy.uint8(FF), LabelFusionNII.affine)
    # nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_FF.nii.gz"))
    
    #R = replaceWMToLeftInBetweenAnyLabels(NewLabelFusionIMG, 4, 41)
    #NewLabelFusionIMG[numpy.logical_and(R, CloserToWMRHDT)] = 41
    #NewLabelFusionIMG[numpy.logical_and(R, CloserToWMRHDT)] = 41

    # DrawEM CC method
    #CSFLToReplace = drawEMCSFReplaceWM(LabelFusionIMG, BrainMaskIMG, 24)
    #ZeroToReplace = drawEMCSFReplaceWM(LabelFusionIMG, BrainMaskIMG, 0)
    

    # nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_labelfusion_csfl.nii.gz"))
    # nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_labelfusion_csfl.nii.gz"))
    # nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_labelfusionimage_csfl.nii.gz"))
    #nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_labelfusion_zerotoreplace.nii.gz"))
    #nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_labelfusion_zerotoreplace.nii.gz"))
    #nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_labelfusionimage_zerotoreplace.nii.gz"))
    
    NewLabelFusionIMG[numpy.logical_and(CCAndThalamusIMGToAdd, CloserToWMLHDT)] = 2
    NewLabelFusionIMG[numpy.logical_and(CCAndThalamusIMGToAdd, CloserToWMRHDT)] = 41
        
    #G = scipy.ndimage.gaussian_laplace(T2IMG, 5)
    
    #PotentialGMinWM = numpy.logical_and(G > 0, Utils.ismember(NewLabelFusionIMG, [2, 41]))
    
    #NewNII = nibabel.Nifti1Image(numpy.uint8(PotentialGMinWM), LabelFusionNII.affine)
    #nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_potgm.nii.gz"))
    
    #NewNII = nibabel.Nifti1Image(numpy.uint8(R), LabelFusionNII.affine)
    #nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_leftdilate3.nii.gz"))
    # fix the problem of GM streaks in the deep WM with the DrawEM label

    LHDrawEMDarkWMMask = numpy.logical_and(DrawEMIMG == 8, CloserToWMLHDT)
    RHDrawEMDarkWMMask = numpy.logical_and(DrawEMIMG == 8, CloserToWMRHDT)

    LHBarrierIMG = numpy.logical_and(CloserToWMLHDT, DrawEMIMG == 3)
    RHBarrierIMG = numpy.logical_and(CloserToWMRHDT, DrawEMIMG == 3)

    nDilate = int(numpy.round(15 / T2NII.header.get_zooms()[0]))

    for i in range(nDilate):
        LHDrawEMDarkWMMask = numpy.logical_and(scipy.ndimage.binary_dilation(LHDrawEMDarkWMMask), LHBarrierIMG)
        RHDrawEMDarkWMMask = numpy.logical_and(scipy.ndimage.binary_dilation(RHDrawEMDarkWMMask), RHBarrierIMG)

    NewLabelFusionIMG[LHDrawEMDarkWMMask] = 2
    NewLabelFusionIMG[RHDrawEMDarkWMMask] = 41

    LHGMMaskIMG = numpy.logical_and(LabelFusionIMG >= 1000, LabelFusionIMG <= 1035)
    RHGMMaskIMG = numpy.logical_and(LabelFusionIMG >= 2000, LabelFusionIMG <= 2035)
    NewLabelFusionIMG[LabelFusionIMG == 254] = 2
    NewLabelFusionIMG[LabelFusionIMG == 255] = 41
    
    NewLabelFusionIMG[LabelFusionIMG == 900] = 2
    NewLabelFusionIMG[LabelFusionIMG == 901] = 41

    BrainMaskIMGDT = scipy.ndimage.distance_transform_edt(BrainMaskIMG, sampling=BrainMaskNII.header.get_zooms())
    
    # go 6mm in from the brain mask
    NewLabelFusionIMG[numpy.logical_and(BrainMaskIMGDT > 6, DrawEMIMGCSFDilated)] = 24
    NewLabelFusionIMG[numpy.logical_and(BrainMaskIMGDT < 3, NewLabelFusionIMG == 2)] = 1000
    NewLabelFusionIMG[numpy.logical_and(BrainMaskIMGDT < 3, NewLabelFusionIMG == 41)] = 2000

    ThirdVentricleDilated = scipy.ndimage.binary_dilation(LabelFusionIMG == 14, iterations = 3)

    NewLabelFusionIMG[numpy.logical_and(ThirdVentricleDilated, CloserToWMLHDT)] = 2
    NewLabelFusionIMG[numpy.logical_and(ThirdVentricleDilated, CloserToWMRHDT)] = 41

    # fill the space between the septums
    M = scipy.ndimage.binary_closing(Utils.ismember(LabelFusionIMG, [900, 901, 192, 9, 48]), iterations=15)
    NewLabelFusionIMG[numpy.logical_and(M, CloserToWMLHDT)] = 2
    NewLabelFusionIMG[numpy.logical_and(M, CloserToWMRHDT)] = 41
    del M

    # replace isthmus WM with DrawEM WM
    NewLabelFusionIMG[numpy.logical_and(NewLabelFusionIMG == 1010, DrawEMIMG == 3)] = 2
    NewLabelFusionIMG[numpy.logical_and(NewLabelFusionIMG == 2010, DrawEMIMG == 3)] = 41

    # set WM labelled regions in the interhemispheric fissure that should be CSF using DrawEM regions
    # dilate DKT GM regions per hemisphere into DrawEM CSF
    LHGMMaskIMG = numpy.logical_and(NewLabelFusionIMG >= 1000, NewLabelFusionIMG <= 1035)
    RHGMMaskIMG = numpy.logical_and(NewLabelFusionIMG >= 2000, NewLabelFusionIMG <= 2035)
    
    DilatedLHGMMaskIMG = scipy.ndimage.binary_dilation(LHGMMaskIMG, iterations=2)
    DilatedRHGMMaskIMG = scipy.ndimage.binary_dilation(RHGMMaskIMG, iterations=2)
    DrawEMCSFMask = DrawEMIMG == 1

    nDilate = 10
    for z in range(nDilate):
        DilatedLHGMMaskIMG = numpy.logical_and(scipy.ndimage.binary_dilation(DilatedLHGMMaskIMG), DrawEMCSFMask)
        DilatedRHGMMaskIMG = numpy.logical_and(scipy.ndimage.binary_dilation(DilatedRHGMMaskIMG), DrawEMCSFMask)

    InterhemisphereMask = numpy.logical_and(DilatedLHGMMaskIMG, DilatedRHGMMaskIMG)
    
    NewLabelFusionIMG[InterhemisphereMask] = 24
    
    NewNII = nibabel.Nifti1Image(numpy.uint8(InterhemisphereMask), LabelFusionNII.affine)
    nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_labelfusion_interhemispheric.nii.gz"))
    # NewNII = nibabel.Nifti1Image(numpy.uint8(DilatedLHGMMaskIMG), LabelFusionNII.affine)
    # nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_labelfusion_intermask_lh.nii.gz"))
    # NewNII = nibabel.Nifti1Image(numpy.uint8(DilatedRHGMMaskIMG), LabelFusionNII.affine)
    # nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_labelfusion_intermask_rh.nii.gz"))

    NewNII = nibabel.Nifti1Image(NewLabelFusionIMG, LabelFusionNII.affine)
    nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_labelfusion_regions.nii.gz"))

    # CCMaskIMG = LabelFusionIMG == 192

    # nDilate = 5

    # LHGMMaskIMGDilated = numpy.array(LHGMMaskIMG)
    # RHGMMaskIMGDilated = numpy.array(RHGMMaskIMG)

    # NotRHGMMaskIMG = numpy.logical_not(RHGMMaskIMG)
    # NotLHGMMaskIMG = numpy.logical_not(LHGMMaskIMG)
    # for i in range(nDilate):
    #     LHGMMaskIMGDilated = numpy.logical_and(scipy.ndimage.binary_dilation(LHGMMaskIMGDilated), NotRHGMMaskIMG)
    #     RHGMMaskIMGDilated = numpy.logical_and(scipy.ndimage.binary_dilation(RHGMMaskIMGDilated), NotLHGMMaskIMG)
    # del NotRHGMMaskIMG
    # del NotLHGMMaskIMG

    # #HGMMaskIMGDilated = dilateWithMaskBarrier(LHGMMaskIMG, RHGMMaskIMG, 5)
    # #HGMMaskIMGDilated = dilateWithMaskBarrier(RHGMMaskIMG, LHGMMaskIMG, 5)
    # GMDilatedOverlapIMG = numpy.logical_and(LHGMMaskIMGDilated, RHGMMaskIMGDilated)

    # CCMaskIMGDilated = numpy.array(LabelFusionIMG == 192)

    # nDilate = 8

    # NotAllGMClosed = numpy.logical_not(allGMClosed)
    # for i in range(nDilate):
    #     CCMaskIMGDilated = numpy.logical_and(scipy.ndimage.binary_dilation(CCMaskIMGDilated), NotAllGMClosed)

    # #el NotAllGMClosed
    # #CCMaskIMGDilated = dilateWithMaskBarrier(CCMaskIMG, allGMClosed, 8)
    # GMDilatedOverlapIMG[CCMaskIMGDilated] = False

    # nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_labelfusion_interhemispheric.nii.gz"))
    
    #NewNII = nibabel.Nifti1Image(numpy.single(numpy.mean(numpy.single(allDKTIMG == 1021), axis = 3)), LabelFusionNII.affine)
    #nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_all_lh_pericalcarine.nii.gz"))

    #NewNII = nibabel.Nifti1Image(numpy.single(numpy.mean(numpy.single(allDKTIMG == 2021), axis = 3)), LabelFusionNII.affine)
    #nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_all_rh_pericalcarine.nii.gz"))

    #NewNII = nibabel.Nifti1Image(numpy.uint8(VoxelsToReplace), LabelFusionNII.affine)
    #nibabel.save(NewNII, os.path.join(TissueSegDir, subjID, subjID + "_voxelstoreplace.nii.gz")    )

if __name__ == "__main__":
    main()
